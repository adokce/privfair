from Compiler.types import sint, regint, Array, MemValue
from Compiler.instructions import listen, acceptclientconnection
from Compiler.library import print_ln, do_while, for_range
from Compiler.util import if_else
from functools import reduce
import operator
program.use_split(3)
program.use_trunc_pr = True
program.options.cisc = True

from ml import *
Layer.n_threads = 4
FixConv2d.use_conv2ds = True

PORTNUM = 14000
MAX_NUM_CLIENTS = 2

N = 48 #public_input()
IMG_SIZE = [48,48,1]

#h = public_input()
#w = public_input()
#c = public_input()
#IMG_SIZE = [h,w,c]

DATA_SIZE = [N] + IMG_SIZE
TRUTH_SIZE = [2,N]
D = reduce(operator.mul, DATA_SIZE)
#M_CONV =  296690 #public_input() 10^6
#M_DENSE = 1188871
M = 1485831 
#M = 1664+36928+36928+73856+147584+132096+1049600+7175

R = 2 * N

STEPS = 10000
EVAL_SIZE_1 = (D+R) // STEPS
EVAL_LEFT = (D+R) - EVAL_SIZE_1*STEPS

M_SIZE_1 = (M) // STEPS
M_LEFT = (M) - M_SIZE_1*STEPS

#print(M,M_SIZE_1,M_LEFT)
num_classes = 7

# define architecture of the CNN
layers = [
        FixConv2d([1,48,48,1], (5,5,1,64), (64,), [1, 44, 44, 64], (1, 1), padding='VALID', tf_weight_format='True'),
        Relu([1, 44, 44, 64]),
        FixAveragePool2d((1, 44, 44, 64), (1, 20, 20, 64), (5, 5),(2,2)),
        FixConv2d((1, 20, 20, 64), ( 3, 3, 64, 64), (64,), (1, 18, 18, 64), (1, 1), padding='VALID', tf_weight_format='True'),
        Relu([1, 18, 18, 64]),
        FixConv2d((1, 18, 18, 64), (3, 3, 64,64), (64,), (1, 16, 16, 64), (1, 1), padding='VALID', tf_weight_format='True'),
        Relu([1, 16, 16, 64]),
        FixAveragePool2d((1, 16, 16, 64), (1, 7, 7, 64), (3, 3),(2,2)),
        FixConv2d((1, 7, 7, 64), ( 3, 3, 64,128), (128,), (1, 5, 5, 128), (1, 1), padding='VALID', tf_weight_format='True'),
        Relu([1, 5, 5, 128]),
        FixConv2d((1, 5, 5, 128), ( 3, 3, 128,128), (128,), (1, 3, 3, 128), (1, 1), padding='VALID', tf_weight_format='True'),
        Relu([1, 3, 3, 128]),
        FixAveragePool2d((1, 3, 3, 128), (1, 1, 1, 128), (3, 3),(2,2)),
        Dense(1,128,1024,activation='relu'),
        Dense(1,1024,1024,activation='relu'),
        Dense(1,1024,7,activation='id'),
        Argmax((1, 7))
        ]
#graph = Optimizer()
#graph.layers = layers

def accept_client():
    client_socket_id = regint()
    acceptclientconnection(client_socket_id, regint(PORTNUM))
    last = regint.read_from_socket(client_socket_id)
    return client_socket_id, last

def close_connections(number_clients):
    @for_range(number_clients)
    def _(i):
        closeclientconnection(i)

def client_input(t,client_socket_id, size):
        return t.receive_from_client(size, client_socket_id)


def inference_fair_metrics(eval_data, model_data, true_result=None):
    
    data = sfix.Tensor(DATA_SIZE)
    truth = sfix.Tensor(TRUTH_SIZE)
    data.assign_vector(eval_data.get_part_vector(0, D))
    truth.assign_vector(eval_data.get_part_vector(D, R))

    sensitive = sint.Array(N)
    y_true = sint.Array(N)
    y_predict = sint.Array(N)

    sensitive.assign_vector(truth[1].get_vector())
    y_true.assign_vector(truth[0].get_vector())
    
    start = 0
    for layer in layers:
        if isinstance(layer,FixConv2d):
                layer.weights.assign_vector(model_data.get_part_vector(start,layer.weights.total_size()))
                start = start + layer.weights.total_size()
                layer.bias.assign_vector(model_data.get_part_vector(start,layer.bias.total_size()))
                start = start + layer.bias.total_size()
        if isinstance(layer,Dense):
                layer.W.assign_vector(model_data.get_part_vector(start,layer.W.total_size()))
                start = start + layer.W.total_size()
                layer.b.assign_vector(model_data.get_part_vector(start,layer.b.total_size()))
                start = start + layer.b.total_size()

    graph = Optimizer()
    graph.layers = layers

    @for_range(N)
    def _(i):
        layers[0].X.assign_vector(data[i].get_vector())
        #print_ln("%s",data[i].reveal_nested())
        #print_ln("%s",layers[0].bias.reveal())
        #print_ln("%s",layers[-2].b.reveal())
        graph.forward(1)
        y_predict[i] = layers[-1].Y[0]
    #print_ln("%s",y_predict.reveal())    
    ## calculate TN,TP,FN,FP
    TP_M = Array(num_classes,sfix)
    TN_M = Array(num_classes,sfix)
    FP_M = Array(num_classes,sfix)
    FN_M = Array(num_classes,sfix)

    TP_F = Array(num_classes,sfix)
    TN_F = Array(num_classes,sfix)
    FP_F = Array(num_classes,sfix)
    FN_F = Array(num_classes,sfix)

    TPR_M = Array(num_classes,sfix)
    TPR_F = Array(num_classes,sfix)
    FPR_M = Array(num_classes,sfix)
    FPR_F = Array(num_classes,sfix)

    for class_ in range(num_classes):
        @for_range_opt(N)
        def _(i):
            truth_is_class = y_true[i].__eq__(class_)
            pred_is_class = y_predict[i].__eq__(class_)
                    
            is_Protected = sensitive[i]

            tp = truth_is_class * pred_is_class   
            tm =is_Protected * truth_is_class
            pm = is_Protected * pred_is_class
            tpm = is_Protected * tp

            TP_M[class_] = TP_M[class_] +    tpm
            FN_M[class_] = FN_M[class_] +   (tm - tpm)
            FP_M[class_] = FP_M[class_] + (pm - tpm)
            TN_M[class_] = TN_M[class_] + (is_Protected - tm -pm + tpm)

            TP_F[class_] = TP_F[class_] + (tp - tpm)
            FN_F[class_] = FN_F[class_] + (truth_is_class - tm - tp + tpm)
            FP_F[class_] = FP_F[class_] + (pred_is_class - pm - tp + tpm)
            TN_F[class_] = TN_F[class_] + (1 - truth_is_class - pred_is_class + tp - is_Protected +tm +tp-tpm)

    ## calculate EOD
        TPR_M[class_] = TP_M[class_] / (TP_M[class_] + FN_M[class_])
        FPR_M[class_] = FP_M[class_] / (FP_M[class_] + TN_M[class_])
        TPR_F[class_] = TP_F[class_] / (TP_F[class_] + FN_F[class_])
        FPR_F[class_] = FP_M[class_] / (FP_M[class_] + TN_M[class_])


    ## accuracy

    ## calculate TN,TP,FN,FP
    TP_M = sint(0)
    TN_M = sint(0)


    TP_F = sint(0)
    TN_F = sint(0)


    count_m = (sum(sensitive))
    count_f = N - count_m



    for class_ in range(num_classes):

        for i in range(N):
            #def _(i):
                truth_is_class = y_true[i].__eq__(class_)
                pred_is_class = y_predict[i].__eq__(class_)
                        
                is_Protected = sensitive[i]

                tp_sum = truth_is_class + pred_is_class
                tp = (tp_sum == 2)
                tn = (tp_sum == 0)

                TP_M = TP_M + (tp * is_Protected)
                TN_M = TN_M + (tn * is_Protected)
                
                TP_F = TP_F + (tp * (1-is_Protected))
                TN_F = TN_F + (tn * (1-is_Protected))



    acc_m = (TP_M + TN_M)# / count_m
    acc_f = (TP_F + TN_F)# / count_f
    #acc_m = acc_m.int_div(count_m)
    #acc_f = acc_f.int_div(count_f)

    
    metrics = []
    @for_range(num_classes)
    def _(i):
         metrics.append(TPR_M[i].v)
         metrics.append(TPR_F[i].v) 
         metrics.append(FPR_M[i].v) 
         metrics.append(FPR_F[i].v) 
         metrics.append(TPR_M[i].v)  
    metrics.append(acc_m.v) 
    metrics.append(acc_f.v) 
    metrics.append(acc.v)
    return metrics




def write_result_to_client(socket, data):
    rnd_from_triple = sint.get_random_triple()[0]
    auth_result = data * rnd_from_triple
    sint.write_shares_to_socket(socket, [data, rnd_from_triple, auth_result])


def main():
    listen(regint(PORTNUM))
    print_ln('Listening for client connections on base port %s', PORTNUM)
    print_ln('Evaluator is player-0, Model owner is player-1')

    def perform_eval(_=None):
        print_ln('Starting evaluation.')

        # Clients socket id (integer).
        client_sockets = Array(MAX_NUM_CLIENTS, regint)
        # Number of clients
        number_clients = MemValue(regint(0))
        # Client ids to identity client
        client_ids = Array(MAX_NUM_CLIENTS, sint)
        # Keep track of received inputs
        seen = Array(MAX_NUM_CLIENTS, regint)
        seen.assign_all(0)

        # Loop round waiting for each client to connect
        @do_while
        def client_connections():
            client_id, last = accept_client()
            @if_(client_id >= MAX_NUM_CLIENTS)
            def _():
                print_ln('client id too high')
                crash()
            client_sockets[client_id] = client_id
            client_ids[client_id] = client_id
            seen[client_id] = 1
            @if_(last == 1)
            def _():
                number_clients.write(client_id + 1)

            return (sum(seen) < number_clients) + (number_clients == 0)

        def start_eval():
            eval_data = sfix.Array(D+R)
            model_params = sfix.Array(M)
            #true_result = sint.Array(R)
            #eval_data.assign(client_input(sfix,regint(0),D+R))
            #true_result.assign(client_input(sint,regint(0),R))
            #model_params.assign(client_input(sfix,regint(1),M))

            

            @for_range(EVAL_SIZE_1)
            def _(i):
                values = sfix.receive_from_client(STEPS, regint(0))
                for j in range(STEPS):
                    eval_data[i * STEPS + j] = values[j]

            values = sfix.receive_from_client(EVAL_LEFT, regint(0))
            for j in range(EVAL_LEFT):
                    eval_data[EVAL_SIZE_1 * STEPS + j] = values[j]


            @for_range(M_SIZE_1)
            def _(i):
                values = sfix.receive_from_client(STEPS, regint(1))
                for j in range(STEPS):
                    model_params[i * STEPS + j] = values[j]

            values = sfix.receive_from_client(M_LEFT, regint(1))
            for j in range(M_LEFT):
                    model_params[M_SIZE_1 * STEPS + j] = values[j]


            metrics = inference_fair_metrics(eval_data, model_params) #,true_result)
            for i in range(len(metrics)):
                write_result_to_client(client_sockets[0],metrics[i])

        start_eval()
        

        close_connections(number_clients)

        return True

    for_range(1)(perform_eval)

main()
